{"ast":null,"code":"// src/infiniteQueryBehavior.ts\nimport { addConsumeAwareSignal, addToEnd, addToStart, ensureQueryFn } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      var _context$fetchOptions, _context$state$data, _context$state$data2;\n      const options = context.options;\n      const direction = (_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 || (_context$fetchOptions = _context$fetchOptions.meta) === null || _context$fetchOptions === void 0 || (_context$fetchOptions = _context$fetchOptions.fetchMore) === null || _context$fetchOptions === void 0 ? void 0 : _context$fetchOptions.direction;\n      const oldPages = ((_context$state$data = context.state.data) === null || _context$state$data === void 0 ? void 0 : _context$state$data.pages) || [];\n      const oldPageParams = ((_context$state$data2 = context.state.data) === null || _context$state$data2 === void 0 ? void 0 : _context$state$data2.pageParams) || [];\n      let result = {\n        pages: [],\n        pageParams: []\n      };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = object => {\n          addConsumeAwareSignal(object, () => context.signal, () => cancelled = true);\n        };\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const createQueryFnContext = () => {\n            const queryFnContext2 = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? \"backward\" : \"forward\",\n              meta: context.options.meta\n            };\n            addSignalProperty(queryFnContext2);\n            return queryFnContext2;\n          };\n          const queryFnContext = createQueryFnContext();\n          const page = await queryFn(queryFnContext);\n          const {\n            maxPages\n          } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages !== null && pages !== void 0 ? pages : oldPages.length;\n          do {\n            var _oldPageParams$;\n            const param = currentPage === 0 ? (_oldPageParams$ = oldPageParams[0]) !== null && _oldPageParams$ !== void 0 ? _oldPageParams$ : options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          var _context$options$pers, _context$options;\n          return (_context$options$pers = (_context$options = context.options).persister) === null || _context$options$pers === void 0 ? void 0 : _context$options$pers.call(_context$options, fetchFn, {\n            client: context.client,\n            queryKey: context.queryKey,\n            meta: context.options.meta,\n            signal: context.signal\n          }, query);\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, _ref) {\n  let {\n    pages,\n    pageParams\n  } = _ref;\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams) : void 0;\n}\nfunction getPreviousPageParam(options, _ref2) {\n  var _options$getPreviousP;\n  let {\n    pages,\n    pageParams\n  } = _ref2;\n  return pages.length > 0 ? (_options$getPreviousP = options.getPreviousPageParam) === null || _options$getPreviousP === void 0 ? void 0 : _options$getPreviousP.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"names":["addConsumeAwareSignal","addToEnd","addToStart","ensureQueryFn","infiniteQueryBehavior","pages","onFetch","context","query","_context$fetchOptions","_context$state$data","_context$state$data2","options","direction","fetchOptions","meta","fetchMore","oldPages","state","data","oldPageParams","pageParams","result","currentPage","fetchFn","cancelled","addSignalProperty","object","signal","queryFn","fetchPage","param","previous","Promise","reject","length","resolve","createQueryFnContext","queryFnContext2","client","queryKey","pageParam","queryFnContext","page","maxPages","addTo","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","remainingPages","_oldPageParams$","initialPageParam","persister","_context$options$pers","_context$options","call","_ref","lastIndex","_ref2","_options$getPreviousP","hasNextPage","hasPreviousPage"],"sources":["/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts"],"sourcesContent":["import {\n  addConsumeAwareSignal,\n  addToEnd,\n  addToStart,\n  ensureQueryFn,\n} from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          addConsumeAwareSignal(\n            object,\n            () => context.signal,\n            () => (cancelled = true),\n          )\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}