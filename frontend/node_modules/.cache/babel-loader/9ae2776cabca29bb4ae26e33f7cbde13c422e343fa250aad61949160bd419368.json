{"ast":null,"code":"import _asyncIterator from \"/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n// src/streamedQuery.ts\nimport { addConsumeAwareSignal, addToEnd } from \"./utils.js\";\nfunction streamedQuery(_ref) {\n  let {\n    streamFn,\n    refetchMode = \"reset\",\n    reducer = (items, chunk) => addToEnd(items, chunk),\n    initialValue = []\n  } = _ref;\n  return async context => {\n    var _context$client$getQu;\n    const query = context.client.getQueryCache().find({\n      queryKey: context.queryKey,\n      exact: true\n    });\n    const isRefetch = !!query && query.state.data !== void 0;\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n    let result = initialValue;\n    let cancelled = false;\n    const streamFnContext = addConsumeAwareSignal({\n      client: context.client,\n      meta: context.meta,\n      queryKey: context.queryKey,\n      pageParam: context.pageParam,\n      direction: context.direction\n    }, () => context.signal, () => cancelled = true);\n    const stream = await streamFn(streamFnContext);\n    const isReplaceRefetch = isRefetch && refetchMode === \"replace\";\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        {\n          if (cancelled) {\n            break;\n          }\n          if (isReplaceRefetch) {\n            result = reducer(result, chunk);\n          } else {\n            context.client.setQueryData(context.queryKey, prev => reducer(prev === void 0 ? initialValue : prev, chunk));\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if (isReplaceRefetch && !cancelled) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n    return (_context$client$getQu = context.client.getQueryData(context.queryKey)) !== null && _context$client$getQu !== void 0 ? _context$client$getQu : initialValue;\n  };\n}\nexport { streamedQuery };","map":{"version":3,"names":["addConsumeAwareSignal","addToEnd","streamedQuery","_ref","streamFn","refetchMode","reducer","items","chunk","initialValue","context","_context$client$getQu","query","client","getQueryCache","find","queryKey","exact","isRefetch","state","data","setState","status","error","fetchStatus","result","cancelled","streamFnContext","meta","pageParam","direction","signal","stream","isReplaceRefetch","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","value","setQueryData","prev","err","return","getQueryData"],"sources":["/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@tanstack/query-core/src/streamedQuery.ts"],"sourcesContent":["import { addConsumeAwareSignal, addToEnd } from './utils'\nimport type {\n  OmitKeyof,\n  QueryFunction,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\ntype BaseStreamedQueryParams<TQueryFnData, TQueryKey extends QueryKey> = {\n  streamFn: (\n    context: QueryFunctionContext<TQueryKey>,\n  ) => AsyncIterable<TQueryFnData> | Promise<AsyncIterable<TQueryFnData>>\n  refetchMode?: 'append' | 'reset' | 'replace'\n}\n\ntype SimpleStreamedQueryParams<\n  TQueryFnData,\n  TQueryKey extends QueryKey,\n> = BaseStreamedQueryParams<TQueryFnData, TQueryKey> & {\n  reducer?: never\n  initialValue?: never\n}\n\ntype ReducibleStreamedQueryParams<\n  TQueryFnData,\n  TData,\n  TQueryKey extends QueryKey,\n> = BaseStreamedQueryParams<TQueryFnData, TQueryKey> & {\n  reducer: (acc: TData, chunk: TQueryFnData) => TData\n  initialValue: TData\n}\n\ntype StreamedQueryParams<TQueryFnData, TData, TQueryKey extends QueryKey> =\n  | SimpleStreamedQueryParams<TQueryFnData, TQueryKey>\n  | ReducibleStreamedQueryParams<TQueryFnData, TData, TQueryKey>\n\n/**\n * This is a helper function to create a query function that streams data from an AsyncIterable.\n * Data will be an Array of all the chunks received.\n * The query will be in a 'pending' state until the first chunk of data is received, but will go to 'success' after that.\n * The query will stay in fetchStatus 'fetching' until the stream ends.\n * @param queryFn - The function that returns an AsyncIterable to stream data from.\n * @param refetchMode - Defines how re-fetches are handled.\n * Defaults to `'reset'`, erases all data and puts the query back into `pending` state.\n * Set to `'append'` to append new data to the existing data.\n * Set to `'replace'` to write all data to the cache once the stream ends.\n * @param reducer - A function to reduce the streamed chunks into the final data.\n * Defaults to a function that appends chunks to the end of the array.\n * @param initialValue - Initial value to be used while the first chunk is being fetched, and returned if the stream yields no values.\n */\nexport function streamedQuery<\n  TQueryFnData = unknown,\n  TData = Array<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n>({\n  streamFn,\n  refetchMode = 'reset',\n  reducer = (items, chunk) =>\n    addToEnd(items as Array<TQueryFnData>, chunk) as TData,\n  initialValue = [] as TData,\n}: StreamedQueryParams<TQueryFnData, TData, TQueryKey>): QueryFunction<\n  TData,\n  TQueryKey\n> {\n  return async (context) => {\n    const query = context.client\n      .getQueryCache()\n      .find({ queryKey: context.queryKey, exact: true })\n    const isRefetch = !!query && query.state.data !== undefined\n    if (isRefetch && refetchMode === 'reset') {\n      query.setState({\n        status: 'pending',\n        data: undefined,\n        error: null,\n        fetchStatus: 'fetching',\n      })\n    }\n\n    let result = initialValue\n\n    let cancelled: boolean = false as boolean\n    const streamFnContext = addConsumeAwareSignal<\n      OmitKeyof<typeof context, 'signal'>\n    >(\n      {\n        client: context.client,\n        meta: context.meta,\n        queryKey: context.queryKey,\n        pageParam: context.pageParam,\n        direction: context.direction,\n      },\n      () => context.signal,\n      () => (cancelled = true),\n    )\n\n    const stream = await streamFn(streamFnContext)\n\n    const isReplaceRefetch = isRefetch && refetchMode === 'replace'\n\n    for await (const chunk of stream) {\n      if (cancelled) {\n        break\n      }\n\n      if (isReplaceRefetch) {\n        // don't append to the cache directly when replace-refetching\n        result = reducer(result, chunk)\n      } else {\n        context.client.setQueryData<TData>(context.queryKey, (prev) =>\n          reducer(prev === undefined ? initialValue : prev, chunk),\n        )\n      }\n    }\n\n    // finalize result: replace-refetching needs to write to the cache\n    if (isReplaceRefetch && !cancelled) {\n      context.client.setQueryData<TData>(context.queryKey, result)\n    }\n\n    return context.client.getQueryData(context.queryKey) ?? initialValue\n  }\n}\n"],"mappings":";;AAAA,SAASA,qBAAA,EAAuBC,QAAA,QAAgB;AAkDzC,SAASC,cAAAC,IAAA,EAad;EAAA,IATA;IACAC,QAAA;IACAC,WAAA,GAAc;IACdC,OAAA,GAAUA,CAACC,KAAA,EAAOC,KAAA,KAChBP,QAAA,CAASM,KAAA,EAA8BC,KAAK;IAC9CC,YAAA,GAAe;EACjB,IAAAN,IAAA;EAIE,OAAO,MAAOO,OAAA,IAAY;IAAA,IAAAC,qBAAA;IACxB,MAAMC,KAAA,GAAQF,OAAA,CAAQG,MAAA,CACnBC,aAAA,CAAc,EACdC,IAAA,CAAK;MAAEC,QAAA,EAAUN,OAAA,CAAQM,QAAA;MAAUC,KAAA,EAAO;IAAK,CAAC;IACnD,MAAMC,SAAA,GAAY,CAAC,CAACN,KAAA,IAASA,KAAA,CAAMO,KAAA,CAAMC,IAAA,KAAS;IAClD,IAAIF,SAAA,IAAab,WAAA,KAAgB,SAAS;MACxCO,KAAA,CAAMS,QAAA,CAAS;QACbC,MAAA,EAAQ;QACRF,IAAA,EAAM;QACNG,KAAA,EAAO;QACPC,WAAA,EAAa;MACf,CAAC;IACH;IAEA,IAAIC,MAAA,GAAShB,YAAA;IAEb,IAAIiB,SAAA,GAAqB;IACzB,MAAMC,eAAA,GAAkB3B,qBAAA,CAGtB;MACEa,MAAA,EAAQH,OAAA,CAAQG,MAAA;MAChBe,IAAA,EAAMlB,OAAA,CAAQkB,IAAA;MACdZ,QAAA,EAAUN,OAAA,CAAQM,QAAA;MAClBa,SAAA,EAAWnB,OAAA,CAAQmB,SAAA;MACnBC,SAAA,EAAWpB,OAAA,CAAQoB;IACrB,GACA,MAAMpB,OAAA,CAAQqB,MAAA,EACd,MAAOL,SAAA,GAAY,IACrB;IAEA,MAAMM,MAAA,GAAS,MAAM5B,QAAA,CAASuB,eAAe;IAE7C,MAAMM,gBAAA,GAAmBf,SAAA,IAAab,WAAA,KAAgB;IAAA,IAAA6B,yBAAA;IAAA,IAAAC,iBAAA;IAAA,IAAAC,cAAA;IAAA;MAEtD,SAAAC,SAAA,GAAAC,cAAA,CAA0BN,MAAA,GAAAO,KAAA,EAAAL,yBAAA,KAAAK,KAAA,SAAAF,SAAA,CAAAG,IAAA,IAAAC,IAAA,EAAAP,yBAAA,UAAQ;QAAA,MAAjB1B,KAAA,GAAA+B,KAAA,CAAAG,KAAA;QAAA;UACf,IAAIhB,SAAA,EAAW;YACb;UACF;UAEA,IAAIO,gBAAA,EAAkB;YAEpBR,MAAA,GAASnB,OAAA,CAAQmB,MAAA,EAAQjB,KAAK;UAChC,OAAO;YACLE,OAAA,CAAQG,MAAA,CAAO8B,YAAA,CAAoBjC,OAAA,CAAQM,QAAA,EAAW4B,IAAA,IACpDtC,OAAA,CAAQsC,IAAA,KAAS,SAAYnC,YAAA,GAAemC,IAAA,EAAMpC,KAAK,CACzD;UACF;QAAA;MACF;IAAA,SAAAqC,GAAA;MAAAV,iBAAA;MAAAC,cAAA,GAAAS,GAAA;IAAA;MAAA;QAAA,IAAAX,yBAAA,IAAAG,SAAA,CAAAS,MAAA;UAAA,MAAAT,SAAA,CAAAS,MAAA;QAAA;MAAA;QAAA,IAAAX,iBAAA;UAAA,MAAAC,cAAA;QAAA;MAAA;IAAA;IAGA,IAAIH,gBAAA,IAAoB,CAACP,SAAA,EAAW;MAClChB,OAAA,CAAQG,MAAA,CAAO8B,YAAA,CAAoBjC,OAAA,CAAQM,QAAA,EAAUS,MAAM;IAC7D;IAEA,QAAAd,qBAAA,GAAOD,OAAA,CAAQG,MAAA,CAAOkC,YAAA,CAAarC,OAAA,CAAQM,QAAQ,eAAAL,qBAAA,cAAAA,qBAAA,GAAKF,YAAA;EAC1D;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}