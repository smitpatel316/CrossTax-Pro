{"ast":null,"code":"import _objectSpread from \"/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classPrivateMethodInitSpec from \"/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _initialState, _revertState, _cache, _client, _retryer, _defaultOptions, _abortSignalConsumed, _Class_brand;\n// src/query.ts\nimport { ensureQueryFn, noop, replaceData, resolveEnabled, resolveStaleTime, skipToken, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { CancelledError, canFetch, createRetryer } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = (_initialState = /*#__PURE__*/new WeakMap(), _revertState = /*#__PURE__*/new WeakMap(), _cache = /*#__PURE__*/new WeakMap(), _client = /*#__PURE__*/new WeakMap(), _retryer = /*#__PURE__*/new WeakMap(), _defaultOptions = /*#__PURE__*/new WeakMap(), _abortSignalConsumed = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class Query extends Removable {\n  constructor(config) {\n    var _config$state;\n    super();\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _initialState, void 0);\n    _classPrivateFieldInitSpec(this, _revertState, void 0);\n    _classPrivateFieldInitSpec(this, _cache, void 0);\n    _classPrivateFieldInitSpec(this, _client, void 0);\n    _classPrivateFieldInitSpec(this, _retryer, void 0);\n    _classPrivateFieldInitSpec(this, _defaultOptions, void 0);\n    _classPrivateFieldInitSpec(this, _abortSignalConsumed, void 0);\n    _classPrivateFieldSet(_abortSignalConsumed, this, false);\n    _classPrivateFieldSet(_defaultOptions, this, config.defaultOptions);\n    this.setOptions(config.options);\n    this.observers = [];\n    _classPrivateFieldSet(_client, this, config.client);\n    _classPrivateFieldSet(_cache, this, _classPrivateFieldGet(_client, this).getQueryCache());\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    _classPrivateFieldSet(_initialState, this, getDefaultState(this.options));\n    this.state = (_config$state = config.state) !== null && _config$state !== void 0 ? _config$state : _classPrivateFieldGet(_initialState, this);\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    var _classPrivateFieldGet2;\n    return (_classPrivateFieldGet2 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.promise;\n  }\n  setOptions(options) {\n    this.options = _objectSpread(_objectSpread({}, _classPrivateFieldGet(_defaultOptions, this)), options);\n    this.updateGcTime(this.options.gcTime);\n    if (this.state && this.state.data === void 0) {\n      const defaultState = getDefaultState(this.options);\n      if (defaultState.data !== void 0) {\n        this.setState(successState(defaultState.data, defaultState.dataUpdatedAt));\n        _classPrivateFieldSet(_initialState, this, defaultState);\n      }\n    }\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      _classPrivateFieldGet(_cache, this).remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n      data,\n      type: \"success\",\n      dataUpdatedAt: options === null || options === void 0 ? void 0 : options.updatedAt,\n      manual: options === null || options === void 0 ? void 0 : options.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    var _classPrivateFieldGet3, _classPrivateFieldGet4;\n    const promise = (_classPrivateFieldGet3 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.promise;\n    (_classPrivateFieldGet4 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(_classPrivateFieldGet(_initialState, this));\n  }\n  isActive() {\n    return this.observers.some(observer => resolveEnabled(observer.options.enabled, this) !== false);\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => resolveStaleTime(observer.options.staleTime, this) === \"static\");\n    }\n    return false;\n  }\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => observer.getCurrentResult().isStale);\n    }\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n  isStaleByTime() {\n    let staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (this.state.data === void 0) {\n      return true;\n    }\n    if (staleTime === \"static\") {\n      return false;\n    }\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    var _classPrivateFieldGet5;\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    observer === null || observer === void 0 || observer.refetch({\n      cancelRefetch: false\n    });\n    (_classPrivateFieldGet5 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.continue();\n  }\n  onOnline() {\n    var _classPrivateFieldGet6;\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    observer === null || observer === void 0 || observer.refetch({\n      cancelRefetch: false\n    });\n    (_classPrivateFieldGet6 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      _classPrivateFieldGet(_cache, this).notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n      if (!this.observers.length) {\n        if (_classPrivateFieldGet(_retryer, this)) {\n          if (_classPrivateFieldGet(_abortSignalConsumed, this)) {\n            _classPrivateFieldGet(_retryer, this).cancel({\n              revert: true\n            });\n          } else {\n            _classPrivateFieldGet(_retryer, this).cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      _classPrivateFieldGet(_cache, this).notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n        type: \"invalidate\"\n      });\n    }\n  }\n  async fetch(options, fetchOptions) {\n    var _classPrivateFieldGet7, _this$options$behavio, _context$fetchOptions;\n    if (this.state.fetchStatus !== \"idle\" &&\n    // If the promise in the retryer is already rejected, we have to definitely\n    // re-start the fetch; there is a chance that the query is still in a\n    // pending state when that happens\n    ((_classPrivateFieldGet7 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.status()) !== \"rejected\") {\n      if (this.state.data !== void 0 && fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.cancelRefetch) {\n        this.cancel({\n          silent: true\n        });\n      } else if (_classPrivateFieldGet(_retryer, this)) {\n        _classPrivateFieldGet(_retryer, this).continueRetry();\n        return _classPrivateFieldGet(_retryer, this).promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = object => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          _classPrivateFieldSet(_abortSignalConsumed, this, true);\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n      const createQueryFnContext = () => {\n        const queryFnContext2 = {\n          client: _classPrivateFieldGet(_client, this),\n          queryKey: this.queryKey,\n          meta: this.meta\n        };\n        addSignalProperty(queryFnContext2);\n        return queryFnContext2;\n      };\n      const queryFnContext = createQueryFnContext();\n      _classPrivateFieldSet(_abortSignalConsumed, this, false);\n      if (this.options.persister) {\n        return this.options.persister(queryFn, queryFnContext, this);\n      }\n      return queryFn(queryFnContext);\n    };\n    const createFetchContext = () => {\n      const context2 = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: _classPrivateFieldGet(_client, this),\n        state: this.state,\n        fetchFn\n      };\n      addSignalProperty(context2);\n      return context2;\n    };\n    const context = createFetchContext();\n    (_this$options$behavio = this.options.behavior) === null || _this$options$behavio === void 0 || _this$options$behavio.onFetch(context, this);\n    _classPrivateFieldSet(_revertState, this, this.state);\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n      _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n        type: \"fetch\",\n        meta: (_context$fetchOptions2 = context.fetchOptions) === null || _context$fetchOptions2 === void 0 ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n    _classPrivateFieldSet(_retryer, this, createRetryer({\n      initialPromise: fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.initialPromise,\n      fn: context.fetchFn,\n      onCancel: error => {\n        if (error instanceof CancelledError && error.revert) {\n          this.setState(_objectSpread(_objectSpread({}, _classPrivateFieldGet(_revertState, this)), {}, {\n            fetchStatus: \"idle\"\n          }));\n        }\n        abortController.abort();\n      },\n      onFail: (failureCount, error) => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"failed\",\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"pause\"\n        });\n      },\n      onContinue: () => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"continue\"\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    }));\n    try {\n      var _classPrivateFieldGet8, _classPrivateFieldGet9, _classPrivateFieldGet0, _classPrivateFieldGet1;\n      const data = await _classPrivateFieldGet(_retryer, this).start();\n      if (data === void 0) {\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \".concat(this.queryHash));\n        }\n        throw new Error(\"\".concat(this.queryHash, \" data is undefined\"));\n      }\n      this.setData(data);\n      (_classPrivateFieldGet8 = (_classPrivateFieldGet9 = _classPrivateFieldGet(_cache, this).config).onSuccess) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.call(_classPrivateFieldGet9, data, this);\n      (_classPrivateFieldGet0 = (_classPrivateFieldGet1 = _classPrivateFieldGet(_cache, this).config).onSettled) === null || _classPrivateFieldGet0 === void 0 || _classPrivateFieldGet0.call(_classPrivateFieldGet1, data, this.state.error, this);\n      return data;\n    } catch (error) {\n      var _classPrivateFieldGet10, _classPrivateFieldGet11, _classPrivateFieldGet12, _classPrivateFieldGet13;\n      if (error instanceof CancelledError) {\n        if (error.silent) {\n          return _classPrivateFieldGet(_retryer, this).promise;\n        } else if (error.revert) {\n          if (this.state.data === void 0) {\n            throw error;\n          }\n          return this.state.data;\n        }\n      }\n      _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n        type: \"error\",\n        error\n      });\n      (_classPrivateFieldGet10 = (_classPrivateFieldGet11 = _classPrivateFieldGet(_cache, this).config).onError) === null || _classPrivateFieldGet10 === void 0 || _classPrivateFieldGet10.call(_classPrivateFieldGet11, error, this);\n      (_classPrivateFieldGet12 = (_classPrivateFieldGet13 = _classPrivateFieldGet(_cache, this).config).onSettled) === null || _classPrivateFieldGet12 === void 0 || _classPrivateFieldGet12.call(_classPrivateFieldGet13, this.state.data, error, this);\n      throw error;\n    } finally {\n      this.scheduleGc();\n    }\n  }\n});\nfunction _dispatch(action) {\n  const reducer = state => {\n    var _action$meta;\n    switch (action.type) {\n      case \"failed\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchFailureCount: action.failureCount,\n          fetchFailureReason: action.error\n        });\n      case \"pause\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchStatus: \"paused\"\n        });\n      case \"continue\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchStatus: \"fetching\"\n        });\n      case \"fetch\":\n        return _objectSpread(_objectSpread(_objectSpread({}, state), fetchState(state.data, this.options)), {}, {\n          fetchMeta: (_action$meta = action.meta) !== null && _action$meta !== void 0 ? _action$meta : null\n        });\n      case \"success\":\n        const newState = _objectSpread(_objectSpread(_objectSpread({}, state), successState(action.data, action.dataUpdatedAt)), {}, {\n          dataUpdateCount: state.dataUpdateCount + 1\n        }, !action.manual && {\n          fetchStatus: \"idle\",\n          fetchFailureCount: 0,\n          fetchFailureReason: null\n        });\n        _classPrivateFieldSet(_revertState, this, action.manual ? newState : void 0);\n        return newState;\n      case \"error\":\n        const error = action.error;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          error,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          fetchFailureReason: error,\n          fetchStatus: \"idle\",\n          status: \"error\",\n          // flag existing data as invalidated if we get a background error\n          // note that \"no data\" always means stale so we can set unconditionally here\n          isInvalidated: true\n        });\n      case \"invalidate\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isInvalidated: true\n        });\n      case \"setState\":\n        return _objectSpread(_objectSpread({}, state), action.state);\n    }\n  };\n  this.state = reducer(this.state);\n  notifyManager.batch(() => {\n    this.observers.forEach(observer => {\n      observer.onQueryUpdate();\n    });\n    _classPrivateFieldGet(_cache, this).notify({\n      query: this,\n      type: \"updated\",\n      action\n    });\n  });\n}\nfunction fetchState(data, options) {\n  return _objectSpread({\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\"\n  }, data === void 0 && {\n    error: null,\n    status: \"pending\"\n  });\n}\nfunction successState(data, dataUpdatedAt) {\n  return {\n    data,\n    dataUpdatedAt: dataUpdatedAt !== null && dataUpdatedAt !== void 0 ? dataUpdatedAt : Date.now(),\n    error: null,\n    isInvalidated: false,\n    status: \"success\"\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt !== null && initialDataUpdatedAt !== void 0 ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport { Query, fetchState };","map":{"version":3,"names":["ensureQueryFn","noop","replaceData","resolveEnabled","resolveStaleTime","skipToken","timeUntilStale","notifyManager","CancelledError","canFetch","createRetryer","Removable","Query","_initialState","WeakMap","_revertState","_cache","_client","_retryer","_defaultOptions","_abortSignalConsumed","_Class_brand","WeakSet","constructor","config","_config$state","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","defaultOptions","setOptions","options","observers","client","_classPrivateFieldGet","getQueryCache","queryKey","queryHash","getDefaultState","state","scheduleGc","meta","promise","_classPrivateFieldGet2","_objectSpread","updateGcTime","gcTime","data","defaultState","setState","successState","dataUpdatedAt","optionalRemove","length","fetchStatus","remove","setData","newData","_assertClassBrand","_dispatch","call","type","updatedAt","manual","setStateOptions","cancel","_classPrivateFieldGet3","_classPrivateFieldGet4","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","queryFn","dataUpdateCount","errorUpdateCount","isStatic","staleTime","isStale","getCurrentResult","isInvalidated","isStaleByTime","arguments","undefined","onFocus","_classPrivateFieldGet5","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","_classPrivateFieldGet6","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","_classPrivateFieldGet7","_this$options$behavio","_context$fetchOptions","status","continueRetry","process","env","NODE_ENV","Array","isArray","console","error","abortController","AbortController","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","createQueryFnContext","queryFnContext2","queryFnContext","persister","createFetchContext","context2","context","behavior","onFetch","fetchMeta","_context$fetchOptions2","initialPromise","fn","onCancel","abort","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","_classPrivateFieldGet8","_classPrivateFieldGet9","_classPrivateFieldGet0","_classPrivateFieldGet1","start","concat","Error","onSuccess","onSettled","_classPrivateFieldGet10","_classPrivateFieldGet11","_classPrivateFieldGet12","_classPrivateFieldGet13","onError","action","reducer","_action$meta","fetchFailureCount","fetchFailureReason","fetchState","newState","errorUpdatedAt","Date","now","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["/home/smitpatel316/projects/cross-border-tax/frontend/node_modules/@tanstack/query-core/src/query.ts"],"sourcesContent":["import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { CancelledError, canFetch, createRetryer } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (this.state && this.state.data === undefined) {\n      const defaultState = getDefaultState(this.options)\n      if (defaultState.data !== undefined) {\n        this.setState(\n          successState(defaultState.data, defaultState.dataUpdatedAt),\n        )\n        this.#initialState = defaultState\n      }\n    }\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  async fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (\n      this.state.fetchStatus !== 'idle' &&\n      // If the promise in the retryer is already rejected, we have to definitely\n      // re-start the fetch; there is a chance that the query is still in a\n      // pending state when that happens\n      this.#retryer?.status() !== 'rejected'\n    ) {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      onCancel: (error) => {\n        if (error instanceof CancelledError && error.revert) {\n          this.setState({\n            ...this.#revertState,\n            fetchStatus: 'idle' as const,\n          })\n        }\n        abortController.abort()\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    try {\n      const data = await this.#retryer.start()\n      // this is more of a runtime guard\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (data === undefined) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.error(\n            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n          )\n        }\n        throw new Error(`${this.queryHash} data is undefined`)\n      }\n\n      this.setData(data)\n\n      // Notify cache callback\n      this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n      this.#cache.config.onSettled?.(\n        data,\n        this.state.error as any,\n        this as Query<any, any, any, any>,\n      )\n      return data\n    } catch (error) {\n      if (error instanceof CancelledError) {\n        if (error.silent) {\n          // silent cancellation implies a new fetch is going to be started,\n          // so we piggyback onto that promise\n          return this.#retryer.promise\n        } else if (error.revert) {\n          // transform error into reverted state data\n          // if the initial fetch was cancelled, we have no data, so we have\n          // to get reject with a CancelledError\n          if (this.state.data === undefined) {\n            throw error\n          }\n          return this.state.data\n        }\n      }\n      this.#dispatch({\n        type: 'error',\n        error: error as TError,\n      })\n\n      // Notify cache callback\n      this.#cache.config.onError?.(\n        error as any,\n        this as Query<any, any, any, any>,\n      )\n      this.#cache.config.onSettled?.(\n        this.state.data,\n        error as any,\n        this as Query<any, any, any, any>,\n      )\n\n      throw error // rethrow the error for further handling\n    } finally {\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          const newState = {\n            ...state,\n            ...successState(action.data, action.dataUpdatedAt),\n            dataUpdateCount: state.dataUpdateCount + 1,\n            ...(!action.manual && {\n              fetchStatus: 'idle' as const,\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          // For manual updates, capture the state to revert to it in case of a cancellation.\n          this.#revertState = action.manual ? newState : undefined\n\n          return newState\n        case 'error':\n          const error = action.error\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n            // flag existing data as invalidated if we get a background error\n            // note that \"no data\" always means stale so we can set unconditionally here\n            isInvalidated: true,\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction successState<TData>(data: TData | undefined, dataUpdatedAt?: number) {\n  return {\n    data,\n    dataUpdatedAt: dataUpdatedAt ?? Date.now(),\n    error: null,\n    isInvalidated: false,\n    status: 'success' as const,\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? options.initialDataUpdatedAt()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}